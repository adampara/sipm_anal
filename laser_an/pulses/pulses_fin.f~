      REAL FUNCTION pulses_fin(thr,chicut)

c        find all the pulses by decomposition of the waveform into a 
c        linear combination of templates
c
c        identify the non-quenched pulses
c        write all the pulses for the conversion to ntuples
c
c        July 5, 2014
c        
c         July 20, 2014
c             add n_puls_nq and puls_q
*********************************************************
*                                                       *
* This file was generated by HUWFUN.                    *
*                                                       *
*********************************************************
*
*     Ntuple Id:      30   
*     Ntuple Title:   Waveforms
*     Creation:       15/07/2013 14.23.15
*
*********************************************************
*
      LOGICAL         CHAIN
      CHARACTER*128   CFILE
      INTEGER         IDNEVT,NCHEVT,ICHEVT
      REAL            OBS(13)
*
      COMMON /PAWIDN/ IDNEVT,OBS
      COMMON /PAWCHN/ CHAIN, NCHEVT, ICHEVT
      COMMON /PAWCHC/ CFILE
*
*--   Ntuple Variable Declarations
*
      REAL wf(10000),yorig,yref,yinc,t0,toff
      INTEGER N_wf,is,iwf
*
      COMMON /PAWCR4/ N_wf,wf,yorig,yref,yinc,t0,is,iwf,toff
*
      common/wave/wave(10000),wf_orig(10000)
      vector coh_noi
      vector wform
      include 'pulses_fin_inc.f'

c     ***   coh_noi is a vector with coherent baseline
c     ***  subtract coherent noise

c      print *,'test1'
      do i = 1,10000
        wave(i) = wf(i) - coh_noi(i)
        wf_orig(i) = wave(i)
        wform(i) = wave(i)
      enddo

      call hist_wave(100)

      call fill_head(N_wf)
      N_puls = 0
      ipulse = 0

      nupper = 9200
      do i = 201,nupper

         if(i.gt.nupper) goto 110
c         print *,' index ',i
c         if(i.gt.8900) print *,i,wave(i),thr
         if(wave(i).lt.thr) goto 900
         call match(i,ibest,chibest,xnorm)
         if(ibest.lt.200.or.ibest.gt.9200) goto 900
         if(xnorm.lt.thr .or. chibest.gt.chicut) goto 900

         call hist_templ(200,ibest,xnorm)

         ipulse = ipulse + 1

         call fill_pulse(ipulse,ibest,chibest,xnorm)

c         print *,'pulse ',ipulse,ibest,xnorm
         call  subtract_templ(ibest,xnorm)
         call hist_wave(100+ipulse)
c         print *,ipulse,i,wave(i)

         call hist_templ(200+ipulse,ibest,xnorm)
         call hfill(999,chibest,xnorm,1.)
c         print *,ipulse,ibest,chibest,xnorm
         i = ibest + 5
 900     continue
       

      enddo

 110  continue

c      print *,'test2'
c      print *,'pulse_a, write ntuple info'  
c      print *,'test3'
c           analyze the pulses found to identify the non-quenched pulses
c         print *,nwf,n_puls

      n_mult = 3
      twindow = 2.5e-8

         call find_non_quench(thr,n_mult,twindow)


         if(N_puls.gt.1) then
            do i=2,N_puls
               t_bef(i) = t(i) - t(i-1)
            enddo
            do i=1,N_puls-1
               t_aft(i)= t(i+1) - t(i)
            enddo
         endif

c     print *,nwf,n_puls
      write(37,*)'---------------------'
      write(37,*)nwf
      write(37,117)rlgate
      write(37,117)gate
 117  format(10e13.5)
      write(37,117)q
      write(37,117)q_r1
      write(37,117)q_r2
      write(37,117)q_r3
      write(37,117)q_r4
      write(37,*)start
      write(37,*)N_puls,n_puls_nq
      do i=1,N_puls
         write(37,*)'  peak ',i
         write(37,117)t(i),t_bef(i),t_aft(i)
         write(37,117)chi_peak(i), chi_3tau(i)
         write(37,*)ampl(i)
         write(37,117)wid66(i),wid50(i),wid33(i)
         write(37,*)q_bef(i)
         write(37,*)puls_q(i)
         write(37,117)(pulse(j,i),j=1,200)
      enddo

      pulses_fin = 0

      END


      subroutine hist_wave(idh)
c     -------------------------
      common/wave/wave(10000)

      do i=1,10000
         call hfill(idh,i-0.5,0.,wave(i))
      enddo

      end

      subroutine hist_templ(idh,ipos,xnorm)
c     -------------------------------------

      vector templ 
c      print *,'fill templete',ipos,idh,xnorm
      do i=1,1000
         call hfill(idh,ipos+i-201.5,0.,xnorm*templ(i))
      enddo

      end

      subroutine subtract_templ(ipos,xnorm)
c     ------------------------------------------

      common/wave/wave(10000)
      vector templ 

      do i=1,1000
         if(ipos+i-201.le.10000.and.ipos+1-201.gt.0) then
            wave(ipos+i-201) = wave(ipos+i-201) -
     +                     xnorm*templ(i)
         endif
      enddo

      end
      subroutine match(ithr,ibest,xmin,xnormbest)
c     -------------------------------------------

      xmin = 999

      do j=ithr-3,ithr+5
         a = chi(j,xnorm,12)
c         print *,j,a
         if(a.lt.xmin) then
            xmin = a
            ibest = j
            xnormbest = xnorm

         endif
      enddo

      end

      function chi(ipos,xnorm,len)
c     ----------------------------

      common/wave/wave(10000)
      vector templ

      sum = 0
      sumw = 0
      sumt = 0
c      print *,'chi ',ipos,len
      do j = -3,4
         sumw = sumw + wave(ipos+j)
         sumt = sumt + templ(201+j)
      enddo

      xnorm = sumw/sumt

      do j = - 3,  12, 2
         wv = 0.5* (wave(ipos+j) + wave(ipos+j+1))
         tt = 0.5 * xnorm * (templ(201+j) + templ(201+j+1))
         cont = ( (wv - tt)/wv  )**2

c         cont = ((wave(ipos+j) - xnorm * templ(201+j))/
c     +              wave(ipos+j)  )**2

         sum = sum + cont
c       print *,'  chi ',xnorm,j,ipos,ipos+j,
c     +             cont,wave(ipos+j),xnorm*templ(201+j)
      enddo

      chi = sum

      end

      subroutine fill_head(N_wf)
c     -------------------------------

      common/wave/wave(10000)
      include 'pulses_fin_inc.f'
      vector sampl
      integer igate(10)

      data igate / 10, 20, 30, 40, 50, 75,  100,  200, 400, 800/

      Nwf = N_wf

      start = 4995 

      call calc_head(start,q,igate)
      call calc_head(100,q_r1,igate)
      call calc_head(1100,q_r2,igate)
      call calc_head(2100,q_r3,igate)
      call calc_head(3100,q_r4,igate)

      do i = 1,10
         gate(i) = igate(i)*sampl(1)
      enddo

      do i=1,500
        rlgate(i) = wave(i + 4900)
      enddo

      return
      end

      subroutine calc_head(ist,qq,igate)
c     -------------------------------

      common/wave/wave(10000)
      integer igate(10)
      real qq(10)

c      print *,'calc_head',ist
      do i = 1,10
         qq(i)=0.
         do j=1,igate(i)
            qq(i) = qq(i) + wave(j-1+ist)
         enddo
      enddo

      return
      end


      subroutine fill_pulse(ipulse,ibest,chibest,xnorm)
c     ------------------------------------------------------

      common/wave/wave(10000),wf_orig(10000)

      vector templ
      vector tau
      vector sampl
      include 'pulses_fin_inc.f'
      integer tauint

c      print *,ipulse,ibest,Max_Pulse
      N_puls = ipulse
      tauint  = nint(3*tau(1)/sampl(1))

      if(ipulse.le.Max_Pulse) then
      t(ipulse) = ibest*sampl(1)
      t_bef(ipulse) = 0
      t_aft(ipulse) = 0
 
      chi_peak(ipulse) = chi(ibest,xnorm,12)
      chi_3tau(ipulse) = chi(ibest,xnorm,tauint)

      ampl(ipulse) = xnorm

      wid66(ipulse) = width(0.66,ibest)*sampl(1)
      wid50(ipulse) = width(0.50,ibest)*sampl(1)
      wid33(ipulse) = width(0.33,ibest)*sampl(1)

      q_bef(ipulse) = 0.
      do i = ibest- 50, ibest -10
         q_bef(ipulse) = q_bef(ipulse) + wave(i)
      enddo
      
      do i=1,L_Pulse
        pulse(i,ipulse) = wf_orig(i+ibest-50)
      enddo
      else
         print *,'Too many' ,ipulse, 'Max = ',Max_pulse
        endif

      return
      end

      function width(frac,ipeak)
c     -------------------------------

      common/wave/wave(10000)

      thr = wave(ipeak)*frac
      do i=ipeak,ipeak-100,-2
         if(0.5*(wave(i)+wave(i-1)).lt.thr) goto 10
      enddo

 10   ibeg  = i

      do i=ipeak,ipeak+700,2
         if(0.5*(wave(i)+wave(i+1)).lt.thr) goto 20
      enddo

 20   iend = i

      width = iend - ibeg +1

      return
      end
    
      subroutine find_non_quench(thr,n_mult,twindow)

c     *** candidate for non-quenched pulse: at least n_mult pulses
c     ***    withing twindow form a current pulse

c     ***  non-quenched pulse candidate considered ended when the
c     ***  waveform falls below xfall*pe
*
*--   Ntuple Variable Declarations
*

      common/wave/wave(10000),wf_orig(10000)
      include 'pulses_fin_inc.f'
      vector sampl
      vector wform

      n_mult = 3
      twindow = 2.5e-8

c      print *,'find_non_quench   ===> ',thr,n_mult,t_window
c      print *,'find_non_quench   ===> ',N_puls

c      print *,(wave(i),i=5000,5010)
      i_trail = 0

      n_quench = 0
      ntrue = 0
      nf = 0

      slope_cut = -1.e-3

      do i = 1,N_puls

         ipos = t(i)/sampl(1)
         xn=ampl(i)

c     ***  do not consider pulses before i_trail, they are a part
c     ***  of a non-quenched pulse
         if(ipos.lt.i_trail) goto 100

c     ***   non-quenched pulses are rising   !!!  re-visit this  !!
         call slope(sl,wf_orig,ipos) 
c         print *,ipos,xn, '  slope  ',sl
         if(sl.lt.slope_cut) goto 20

         if(i+n_mult.lt.N_puls) then
c     ***  there must be enough pulses left to be a candidate   
            if(t(i+n_mult)-t(i).lt.twindow) then
c     *** n_mult pulses withnin a winow, it is a non-quenched pulse
               do kk = ipos,10000
                  if(wf_orig(kk).gt.thr) then
                     i_trail = kk
                  else
c     *** found the end of the pulse
c                     print *,'long pulse', ipos, 
c     +                '  end of the pulse ', kk
                     call char_nq_pulse(i,ipos,kk)
                     n_quench = n_quench + 1
                     nf = nf + 1
                     puls_q(i) = 1
                     call copy_pulse(i,nf)
c                     call hist_quench(110+n_quench,wave,
c     +                               ipos-100,kk+100)
                     goto 100
                  endif
               enddo
            endif
c     ***    regular pulse
C          call accumulate(ipos,xn,f_wave)
 20         continue
c            print *,'  regular pulse ',ipos,xn
            ntrue = ntrue + 1
            nf = nf + 1
            puls_q(nf) = 0
            call copy_pulse(i,nf)
            goto 100

c     *******   check if the last pulse(s) needs to be added..
         endif

c         call accumulate(ipos,xn,f_wave)
c         print *,'  regular pulse ',ipos,xn
            ntrue = ntrue + 1
            nf = nf + 1
            puls_q(nf) = 0
            call copy_pulse(i,nf)
 100     continue

c         print *,'  pulse anal ', i, nf
      enddo

      do i = 1,10000
         wform(i) = wf_orig(i)
      enddo

      n_puls = ntrue + n_quench
      n_puls_nq = n_quench

c      print *,' number of quenched  pulses ',ntrue, 
c     +         ' non-quench ',n_quench
c      print *,' total number of pulses ',n_puls

      return
      end

      subroutine slope(sl,array,ipos)

c     ***    for straight line to N points of the array, staring at position ipos 
c     ***    return the slope of the line

      real array(10000)

      N=6

      a11=0
      a12=0
      a21=0
      a22=0
      b1=0
      b2=0

      do i=1,N
         j = ipos - 1 + i
         a11 = a11 + i**2
         a12 = a12 + i
         b1 = b1 + i*array(j)
         b2 = b2 + array(j)  
      enddo

      a21 = a12
      a22 = N

      sl = (b1*a22 - b2*a12)/(a11*a22 - a12*a21)

      end

      subroutine copy_pulse(ior,ifin)
      include 'pulses_fin_inc.f'
c      print *, 'copy pulse ',ior,' into position ',ifin

      t(ifin) = t(ior)

      t_bef(ifin) = 0
      t_aft(ifin) = 0

      chi_peak(ifin) = chi_peak(ior)
      chi_3tau(ifin) = chi_3tau(ior)
      ampl(ifin) = ampl(ior)
      wid66(ifin) = wid66(ior)
      wid50(ifin) = wid50(ior)
      wid33(ifin) = wid33(ior)
      q_bef(ifin) = q_bef(ior)
      puls_q(ifin) = puls_q(ior)

      do i = 1,200
         pulse(i,ifin) = pulse(i,ior)
      enddo

      return
      end
      subroutine char_nq_pulse(ipuls,ipos,kk)

c
c     ***   derive characteristics on non-quenched pulse i
c
      common/wave/wave(10000),wf_orig(10000)
      include 'pulses_fin_inc.f'
      vector sampl

      integer ncount
      parameter ( ncount = 50)
      integer counter(ncount)

      tot_q = 0

c         total charge of the pulse

      do i = ipos,kk
         tot_q = tot_q + wf_orig(i)
      enddo
      
      q_bef(ipuls) = tot_q
c      print *,'tot_q ',tot_q
c        total width of the pulse 
     
      wid66(ipuls) = (kk + 1 - ipos)*sampl(1)

      xmean = 0
      xmean2 = 0
      xmax = -999.


c         mean/max of the pulse

      do i = ipos,kk
         if(wf_orig(i).gt.xmax) xmax = wf_orig(i)
         xmean = xmean + wf_orig(i)/(kk+1-ipos)
         xmean2 = xmean2 + wf_orig(i)/(kk+1-ipos)
      enddo

      sig = sqrt(xmean2 - xmean**2)
      wid50(ipuls) = xmean
      wid33(ipuls) = xmax
      chi_peak(ipuls) =sig

c      print *,' xmean,xmax,sigma', xmean,xmax,sig

c        most probable
     
      call vzero(counter,ncount)

      binw = xmax/ncount

      do i = ipos,kk
         ibin = ifix(wf_orig(i)/binw+0.5)
         if(ibin.gt.0) counter(ibin) = counter(ibin)+1
      enddo

      maxcount = 0
      imax = 0

      do i=2,ncount-1
         icc = counter(i-1)+counter(i)+counter(i+1)
         if(icc.gt.maxcount) then
            maxcount = icc
            imax = i
         endif
      enddo

      ampl(ipuls) = imax*binw
c      print *,' flat ',ampl(ipuls) 
      return
      end
